# Dead Reckoning (데드 레커닝)

- 배경
    - 본래의 의미는 항해할 때 출발위치에서의 속력, 바람, 배의 특성 등등을 고려하여 다음 위치를 추측하는 항법을 의미한다.
    - 컴퓨터에서는 온라인 게임의 네트워크 서버 부하를 줄이는데 쓴다.
    - 최근 자율주행에 대한 관심이 높아지면서, 자율주행하는 물체가 자신의 현재 위치를 추측하는데 사용한다.
- 설명
    - 온라인 게임

    60프레임으로 돌아가는 3D 온라인 게임에서 어떤 캐릭터가 이동하고 있다고 가정해보자. 이 때, 실시간으로 캐릭터의 이동을 처리하려면 1초에 60번 이동에 대한 패킷을 보내야 하고, 서버는 이를 받아서 같은 공간에 있는 모든 유저에게 다시 이동 패킷을 60번 보내서 이동한 캐릭터의 위치를 갱신해야한다. 이것은 엄청난 서버 부하를 가져온다.

    그래서 유저의 상태가 기존 상태에서 변화되었을 때만 패킷을 보내는 방법이 나왔다. 그렇다면 여기서 패킷이 오지 않는 상태일 때는 어떻게 처리할까? 이때 필요한 것이 바로 Dead Reckoning이다. 패킷이 오지 않는 동안에는 이전에 받은 정보를 이용하여 현재 위치를 알아서 계산하는 것이다. 즉 서버와 클라이언트의 트레픽을 줄이면서 동기화하는 방식이다.

    두가지 방법을 비교해 보자. 10명의 유저가 접속해있고 한 명의 유저만 60프레임으로 10초동안 이동했다고 가정하자.

    1. 이동하는 클라이언트가 서버로 600번 이동패킷을 보내고, 서버는 접속해 있는 10명에게 600번씩 전송하여 총 6000번 패킷을 전송하게 된다.(모든 유저의 정보를 업데이트 해야하기 때문에) 결과적으로 서버는 6600번의 패킷을 송수신한다.
    2. 이동하는 클라이언트가 이동 시작시 서버로 이동시작 패킷을 보낸다. 서버는 접속해 있는 10명에게 한번씩 이동시작 패킷을 보낸다.(모두 각자 알아서 계산) 결과적으로 서버는 11번의 패킷을 송수신한다.

    위의 경우는 6589번의 송수신 횟수가 차이난다. 이것이 Dead Recknoing이 온라인 게임에서 효율적인 이유이다.

    - 로봇 공학

    센서에 대한 위치추정을 기반으로 한다. 여기서 센서는 가속도계, 자이로 스코프, 적외선 센서, 카메라 등등이 될 수 있다. 이들의 센서 값을 활용해서 현재의 위치를 추정하는 것이다.

    추정하는 방법은 여러가지가 있고, 가장 간단한 공식은

    $$
    현재 위치 = 이전위치 + (속도*시간) + (1/2*가속도*시간^2)$$

    가속도만을 활용한 공식이 있다. 이외에 센서가 추가될 때마다 공식이 달라지고, 추정의 정밀도도 올라간다.

    추정이다보니 결국 오차가 있고, 추정을 오래하게되면 오차값이 커지게 된다. 따라서 주기적으로 실제 위치를 넣어서 오차를 잡아줄 필요가 있다.

- 착각하지 말것

    이해하기 쉽게하기 위해 온라인 게임의 예를 가져왔는데, 온라인 게임에서 캐릭터의 현재위치를 자동으로 계산하게 해서, 서버 부하를 줄이는 알고리즘 이라고 했지만, 포인트는 '서버 부하를 줄이는 것'이 아니라 '현재 위치를 계산하는 것'이다.

- 결론

    이전의 정보(위치, 속력 등)와 센서값(가속도계, 자이로 스코프, 적외선, 카메라 등)을 활용해 현재 위치를 추정하는 알고리즘(공식은 세우기 나름).

- 참고링크

    [https://hmjo.tistory.com/168](https://hmjo.tistory.com/168)

    [https://cocoa106.tistory.com/entry/온라인-게임의-이동처리-기법-데드-레커닝](https://cocoa106.tistory.com/entry/%EC%98%A8%EB%9D%BC%EC%9D%B8-%EA%B2%8C%EC%9E%84%EC%9D%98-%EC%9D%B4%EB%8F%99%EC%B2%98%EB%A6%AC-%EA%B8%B0%EB%B2%95-%EB%8D%B0%EB%93%9C-%EB%A0%88%EC%BB%A4%EB%8B%9D)

    [https://robotics.stackexchange.com/questions/7287/odometry-vs-dead-reckoning](https://robotics.stackexchange.com/questions/7287/odometry-vs-dead-reckoning)